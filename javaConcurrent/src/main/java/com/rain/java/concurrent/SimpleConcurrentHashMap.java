package com.rain.java.concurrent;
/*
Hashmap的线程安全实现
经历了几个版本的更迭，ConcurrentHashMap也变换过各种实现方式
从之前的分段加锁，到现在全局加锁
17.及以前，会将ConcurrentHashMap中的数组分成几个段落，每个段落保存着一部分hash值，这样，当请求进来的时候，不需要对整个
数组加锁，只需要对相应的段落加锁就可以了。但效率依然没有预期的那么高。
18以后，ConcurrentHashMap改变了策略，不再使用段落的方式，转而使用unsafe高效率类来支撑线程安全问题
同时，Map中的数组也不再使用数组+链表的方式，使用数组+链表+红黑树的方式。
当链表中的数组大于8个（默认）的时候，将会转变方式，创建红黑树，
这个地方和HashMap稍有不同，因为线程安全情况下创建红黑树消耗的资源不菲，所以系统默认
如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树
后续扩容比较复杂，没怎么看，大概意思就是将数组扩容，对原数组采用分段的方式迁移（多线程），最大化利用CPU
同时，如果转换后的条件（链表小于8个节点），会再次转换回链表。
同时，红黑树中的元素仍然维持链表结构
**/
public class SimpleConcurrentHashMap {
}
